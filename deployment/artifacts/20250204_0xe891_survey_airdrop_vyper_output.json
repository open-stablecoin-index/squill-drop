{
  "language": "Vyper",
  "sources": {
    "contracts/ownable_2step.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Ownable 2-step\n@license MIT\n@author yearn.finance, asymmetry.finance\n@notice ownable_2step.vy is a two-step ownable contract that allows for a two-step transfer of ownership\n\"\"\"\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent PendingOwnershipTransfer:\n    old_owner: address\n    new_owner: address\n\n\nevent OwnershipTransferred:\n    old_owner: address\n    new_owner: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\nowner: public(address)\npending_owner: public(address)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice Initializes the contract setting the deployer as the initial owner\n    \"\"\"\n    self.owner = msg.sender\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Starts the ownership transfer of the contract\n         to a new account `new_owner`\n    @notice Note that this function can only be\n            called by the current `owner`. Also, there is\n            no security risk in setting `new_owner` to the\n            zero address as the default value of `pending_owner`\n            is in fact already the zero address and the zero\n            address cannot call `accept_ownership`. Eventually,\n            the function replaces the pending transfer if\n            there is one\n    @param new_owner The address of the new owner\n    \"\"\"\n    self._check_owner()\n    self.pending_owner = new_owner\n    log PendingOwnershipTransfer(self.owner, new_owner)\n\n\n@external\ndef accept_ownership():\n    \"\"\"\n    @dev The new owner accepts the ownership transfer.\n    @notice Note that this function can only be\n            called by the current `pending_owner`\n    \"\"\"\n    assert self.pending_owner == msg.sender, \"!new owner\"\n    self._transfer_ownership(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner\n    \"\"\"\n    assert msg.sender == self.owner, \"!owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner` and deletes\n         any pending owner\n    @notice This is an `internal` function without\n            access restriction\n    @param new_owner The address of the new owner\n    \"\"\"\n    self.pending_owner = empty(address)\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(old_owner, new_owner)\n",
      "sha256sum": "65febf30a2b8904113177dda55aac703ed6df29a612e4a503d756c76ab678869"
    },
    "contracts/pausable.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Pausable\n@license MIT\n@author Leviathan\n@notice pauseable.vy allows to implement an emergency stop mechanism that can be triggered by an authorized account\n\"\"\"\n\nimport ownable_2step as ownable\n\n\n# ============================================================================================\n# Modules\n# ============================================================================================\n\n\nuses: ownable\n\n\n# ============================================================================================\n# Events\n# ============================================================================================\n\n\nevent Paused:\n    account: address\n\n\nevent Unpaused:\n    account: address\n\n\n# ============================================================================================\n# Storage\n# ============================================================================================\n\n\npaused: public(bool)\n\n\n# ============================================================================================\n# Constructor\n# ============================================================================================\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice At initialisation time, the `owner` role will\n            be assigned to the `msg.sender` since we `uses`\n            the `ownable` module, which implements the\n            aforementioned logic at contract creation time.\n    \"\"\"\n    pass\n\n\n# ============================================================================================\n# Owner functions\n# ============================================================================================\n\n\n@external\ndef pause():\n    \"\"\"\n    @dev Pauses the contract\n    \"\"\"\n    ownable._check_owner()\n    self._check_unpaused()\n    self.paused = True\n    log Paused(msg.sender)\n\n\n@external\ndef unpause():\n    \"\"\"\n    @dev Unpauses the contract\n    \"\"\"\n    ownable._check_owner()\n    self._check_paused()\n    self.paused = False\n    log Unpaused(msg.sender)\n\n\n# ============================================================================================\n# Internal functions\n# ============================================================================================\n\n\n@internal\ndef _check_unpaused():\n    \"\"\"\n    @dev Checks if the contract is unpaused\n    \"\"\"\n    assert not self.paused, \"paused\"\n\n\n@internal\ndef _check_paused():\n    \"\"\"\n    @dev Checks if the contract is paused\n    \"\"\"\n    assert self.paused, \"!paused\"\n",
      "sha256sum": "5a62cf2f1a9c567df539c5488b510362dc6ea62b9b0b1ca2c4d894c26e54de8f"
    },
    "contracts/SurveyAirdrop.vy": {
      "content": "# @version 0.4.0\n\n\"\"\"\n@title Big Crypto Poll Reward Distributor\n@license MIT\n@author crv.mktcap.eth\n@notice Details: https://curve.substack.com/p/big-crypto-poll-results\n\n         #################\n       #####################++++\n     ##################+++++++++++++\n    +###############++++++++++++++++++++\n   ++###############+++++++++++++++++++++++\n  +++###############++++++++++++++++++++++++++\n +++++###############+++++++-----++--+++++++++++\n +++++###############++---------------------++++++\n -+++++##############++-----------------------------\n--+++++++############++------------------------------\n---+++++++##########++++------------------------------\n---+++++++++++++++++++++-------------------------------\n----++++++++++++++++++++-------------------------------\n-----+++++++++++++++++++-------------------------------\n---------------+++++++++-------------------------------\n------------------+++++--------------------------------\n-------------------------------------------------------\n ------------------------------------------------------\n -----------------------------------------------------\n --------------------------------------------------+\n +---------------------------------------------++\n  +--------------------------------------+++\n   +---------++++++++----------+++++\n   ++++++++++++++++++----+++++\n    ++++++++++++++++-----+\n     ++++++++++++++++++++\n      #+++++++++++++++++\n       ########++++++++\n        ##############\n          ##########\n\"\"\"\n\nfrom ethereum.ercs import IERC20\n\nimport ownable_2step as ownable\nimport pausable\n\n\n# ================================================================== #\n# \u2699\ufe0f Modules\n# ================================================================== #\n\ninitializes: ownable\nexports: (\n    ownable.owner,\n    ownable.pending_owner,\n    ownable.transfer_ownership,\n    ownable.accept_ownership,\n)\n\ninitializes: pausable[ownable := ownable]\nexports: (\n    pausable.paused,\n    pausable.pause,\n    pausable.unpause,\n)\n\n\n# ================================================================== #\n# \ud83d\udce3 Events\n# ================================================================== #\n\nevent Claim:\n    user: address\n    value: uint256\n\n\n# ================================================================== #\n# \ud83d\udcbe Storage\n# ================================================================== #\n\nreward_token: public(IERC20)\nreward_amount: public(uint256)\neligible_addresses: public(HashMap[address, bool])\n\n\n# ================================================================== #\n# \ud83d\udea7 Constructor\n# ================================================================== #\n\n@deploy\ndef __init__(reward_token: IERC20, reward_amount: uint256):\n    assert (\n        reward_amount > 0 and reward_amount <= max_value(uint256) // 2\n    ), \"!amount\"\n\n    ownable.__init__()\n    pausable.__init__()\n    self.reward_token = reward_token\n    self.reward_amount = reward_amount\n\n\n# ================================================================== #\n# \ud83d\udc40 View Functions\n# ================================================================== #\n\n@external\n@view\ndef pending_claim_amount(addr: address) -> uint256:\n    \"\"\"\n    @notice Pending claim amount\n    @param addr Address to check\n    @return Amount of tokens received on claim\n    \"\"\"\n    if self.eligible_addresses[addr]:\n        return self.reward_amount\n    return 0\n\n\n# ================================================================== #\n# \u270d\ufe0f Write Functions\n# ================================================================== #\n\n@external\ndef claim():\n    \"\"\"\n    @notice Allows whitelisted addresses to withdraw tokens\n    \"\"\"\n    self._claim(msg.sender)\n\n\n@external\ndef claim_for(addr: address):\n    \"\"\"\n    @notice Allows whitelisted addresses to withdraw tokens\n    @param addr Eligible address for claim\n    \"\"\"\n    # ownable._check_owner()\n    self._claim(addr)\n\n\n# ================================================================== #\n# \ud83d\udc51 Admin Functions\n# ================================================================== #\n\n@external\ndef add_address(addr: address):\n    \"\"\"\n    @notice Adds an address to the whitelist\n    @param addr Address to add\n    \"\"\"\n\n    ownable._check_owner()\n    self.eligible_addresses[addr] = True\n\n\n@external\ndef remove_address(addr: address):\n    \"\"\"\n    @notice Removes an address from the whitelist\n    @param addr Address to remove\n    \"\"\"\n    ownable._check_owner()\n    self.eligible_addresses[addr] = False\n\n\n@external\ndef withdraw_remaining(_token: IERC20):\n    \"\"\"\n    @notice Allows owner to withdraw any remaining tokens\n    @param _token Token address to withdraw\n    \"\"\"\n    ownable._check_owner()\n    amount: uint256 = staticcall _token.balanceOf(self)\n    assert amount > 0, \"!balance\"\n    assert extcall _token.transfer(msg.sender, amount), \"!transfer\"\n\n\n# ================================================================== #\n# \ud83c\udfe0 Internal Functions\n# ================================================================== #\n\n@internal\ndef _claim(_user: address):\n    pausable._check_unpaused()\n    assert self.eligible_addresses[_user], \"!address\"\n\n    _amount: uint256 = self.reward_amount\n    _balance: uint256 = staticcall self.reward_token.balanceOf(self)\n    assert _balance >= _amount, \"!balance\"\n\n    # Update state before transfer\n    self.eligible_addresses[_user] = False\n\n    # Transfer tokens to the caller\n    assert extcall self.reward_token.transfer(_user, _amount), \"!transfer\"\n\n    log Claim(_user, self.reward_amount)\n",
      "sha256sum": "430d8b615afabe7c350aeab26a97c100969d2f0ddd112b367b9855dd0f3071b9"
    }
  },
  "settings": {
    "outputSelection": {
      "contracts/SurveyAirdrop.vy": [
        "*"
      ]
    },
    "search_paths": [
      "."
    ]
  },
  "compiler_version": "v0.4.0+commit.e9db8d9",
  "integrity": "0900f5dd91ffe9facc0182ebb14860a6d5a59cb8da8ce447df5e65a0f809aee7"
}